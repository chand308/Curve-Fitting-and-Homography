# -*- coding: utf-8 -*-
"""Problem3(1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y56ZKzhCBR1okbaBQjjcYyoWIA3YxWJG
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import pandas as pd
from sklearn import preprocessing
from numpy.linalg import eig
import matplotlib.pyplot as plt
# %matplotlib inline
import math

df = pd.read_csv('/content/ENPM673_hw1_linear_regression_dataset - Sheet1.csv')
print(df.head())

df.keys()

df.shape

#Let us delete the columns that are not required
df.drop(['sex', 'bmi', 'children','smoker','region'], axis=1, inplace=True)
print(df.head())

x = df.values #returns a numpy array
min_max_scaler = preprocessing.MinMaxScaler()
x_scaled = min_max_scaler.fit_transform(x)
df = pd.DataFrame(x_scaled)

df.head()

df = df.rename(columns={0: "age", 1: "charges"})
df.head()

#calculate the mean for age variable.
mean_age = np.sum(df['age'])/len(df['age'])
print(mean_age)

#calculate the mean for the insurance cost variable.
mean_charges = np.sum(df['charges'])/len(df['charges'])
print(mean_charges)

#find the variance of the age variable
var_age = 0
for i in list(df['age']):
  x = (i - mean_age)**2/(len(df['charges'])-1)
  var_age = var_age + x
print(var_age)

#find the variance of the charges variable
var_charges = 0
for j in list(df['charges']):
  x = (j - mean_charges)**2/(len(df['charges'])-1)
  var_charges = var_charges + x
print(var_charges)

#find the covariance
a = df['age'] - mean_age
b = df['charges'] - mean_charges
covariance = np.dot(a,b)/(len(df['charges'])-1)
covariance_matrix = np.array([[var_age, covariance],[covariance,var_charges]])
print(covariance_matrix)

#compute the Eigen values and Eigen vectors of the covariance matrix
w,v=eig(covariance_matrix)
print('E-value:', w)
print('E-vector', v)

eig_vec1 = v[:,0]
eig_vec2 = v[:,1]
print(eig_vec1)
print(eig_vec2)

plt.quiver(*eig_vec1, color=['r'])
plt.quiver(*eig_vec2, color=['b'])
plt.show()

#plot the data
plt.scatter(df['age'], df['charges'])
origin = [mean_age,mean_charges]
plt.quiver(*origin,*eig_vec1, color=['r'],scale=10)
plt.quiver(*origin,*eig_vec2, color=['b'],scale=10)
plt.show()

#Linear Least square method
a = np.array(df['age'])
A = np.vstack([a, np.ones(len(a))]).T
B = np.array(df['charges'])
B = B[:, np.newaxis]

pseudo_inverse = np.dot((np.dot(np.linalg.inv(np.dot(A.T,A)),A.T)),B)
print(pseudo_inverse)

# plot the results
plt.figure(figsize = (10,8))
plt.plot(A,B, 'b.')
plt.plot(A, pseudo_inverse[0]*A + pseudo_inverse[1], 'r')
plt.show()

#Ransac
x = df['age']
y = df['charges']
x1 = x
y1 = y
O = np.ones(325)
x = np.column_stack((O,x))

class linearleastsquare:

    def fit(self,x,y):
        X_dagger = np.dot(np.linalg.inv(np.dot(x.T, x)), x.T)
        weights = np.dot(X_dagger, y)
        return weights

class Ransac:
    def __init__(self, weights):
        self.weights = weights
    
    def fit(self,x,y,threshold):

        num_iter = math.inf
        num_sample = 2

        max_inlier_count = 0
        best_model = None

        desired_prob = 0.95
        prob_outlier = 0.5
        
        data = np.column_stack((x, y)) 
        data_size = len(data)

        iter_done = 0

        while num_iter > iter_done:

            np.random.shuffle(data)
            sample_data = data[:num_sample, :]
            estimated_model = self.weights.fit(sample_data[:,:-1], sample_data[:, -1])

            y_cap = x.dot(estimated_model)
            err = np.abs(y - y_cap.T)
            inlier_count = np.count_nonzero(err < threshold)
 
            if inlier_count > max_inlier_count:
                max_inlier_count = inlier_count
                best_model = estimated_model


            prob_outlier = 1 - inlier_count/data_size
            print('No.of inliers:', inlier_count)
            print('probability of outlier:', prob_outlier)
            num_iter = np.ceil(math.log(1 - desired_prob)/math.log(1 - (1 - prob_outlier)**num_sample))
            iter_done = iter_done + 1

            print(' iterations done:', iter_done)
            print('no.of.iterations expected:', num_iter)
            print('max_inlier_count: ', max_inlier_count)

        return best_model

lls = linearleastsquare()
ransac_model = Ransac(lls)
threshold = np.std(y)/2
est = ransac_model.fit(x,y,threshold)
ransac = x.dot(est)

plt.plot(x1,y1,'o',color = (0,0,1))
plt.plot(x1,ransac,color ='red')
plt.show()